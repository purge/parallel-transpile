// Generated by CoffeeScript 1.9.1
var Path, fs, init, loaders, mkdirp, output, send, source, swapExtension;

fs = require('fs');

Path = require('path');

mkdirp = require('mkdirp');

loaders = {};

source = null;

output = null;

send = function(message) {
  if (message instanceof Error) {
    console.error(message.stack);
    message = {
      error: true,
      message: message.toString(),
      stack: message.stack
    };
  }
  return process.send(message);
};

init = function(options) {
  source = options.source.replace(/\/*$/, "/");
  return output = options.output.replace(/\/+$/, "");
};

swapExtension = function(path, a, b) {
  if (path.substr(path.length - a.length) === a) {
    return path.substr(0, path.length - a.length) + b;
  }
  return path;
};

process.on('message', function(m) {
  var _, applyNext, err, finished, i, inExt, j, len, loader, loaderModule, mapPath, moduleName, outExt, outPath, path, query, ref, ref1, relativePath, remainingLoaderModules, sourceMap, src, webpackLoaders;
  if (m.init) {
    return init(m.init);
  }
  if (!source) {
    throw new Error("Not initialised");
  }
  path = m.path, (ref = m.rule, inExt = ref.inExt, loaders = ref.loaders, outExt = ref.outExt);
  relativePath = path.substr(source.length);
  outPath = output + "/" + (swapExtension(relativePath, inExt, outExt));
  mapPath = output + "/" + (swapExtension(relativePath, inExt, ".map"));
  webpackLoaders = [];
  for (j = 0, len = loaders.length; j < len; j++) {
    loader = loaders[j];
    try {
      ref1 = loader.match(/^([^?]+)(\?.*)?$/), _ = ref1[0], moduleName = ref1[1], query = ref1[2];
      loaderModule = require(moduleName);
      webpackLoaders.push({
        request: "",
        path: path,
        query: query,
        module: loaderModule
      });
    } catch (_error) {
      err = _error;
      return send(err);
    }
  }
  src = fs.readFileSync(path, 'utf8');
  sourceMap = null;
  remainingLoaderModules = webpackLoaders.slice(0);
  i = remainingLoaderModules.length;
  finished = function() {
    mkdirp.sync(Path.dirname(outPath));
    fs.writeFileSync(outPath, src);
    if (sourceMap) {
      fs.writeFileSync(mapPath, sourceMap);
    }
    return send('complete');
  };
  applyNext = function() {
    var asyncCallback, context, next, out;
    next = remainingLoaderModules.pop();
    i--;
    if (!next) {
      return finished();
    }
    asyncCallback = false;
    context = {
      version: 1,
      path: next.path,
      request: next.request,
      query: next.query,
      sourceMap: sourceMap,
      loaderIndex: i,
      loaders: webpackLoaders,
      async: function() {
        return asyncCallback = true;
      },
      callback: function(err, js, map) {
        asyncCallback = true;
        if (err) {
          send(err);
          return;
        }
        src = js;
        sourceMap = map;
        return applyNext();
      }
    };
    try {
      out = next.module.call(context, src);
      if (!asyncCallback) {
        src = out;
        return applyNext();
      }
    } catch (_error) {
      err = _error;
      send(err);
    }
  };
  return applyNext();
});

//# sourceMappingURL=worker.js.map
