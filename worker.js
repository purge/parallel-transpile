// Generated by CoffeeScript 1.9.1
var Path, fs, init, loaders, mkdirp, output, source, swapExtension;

fs = require('fs');

Path = require('path');

mkdirp = require('mkdirp');

loaders = {};

source = null;

output = null;

init = function(options) {
  source = options.source.replace(/\/*$/, "/");
  return output = options.output.replace(/\/+$/, "");
};

swapExtension = function(path, a, b) {
  if (path.substr(path.length - a.length) === a) {
    return path.substr(0, path.length - a.length) + b;
  }
  return path;
};

process.on('message', function(m) {
  var applyNext, e, finished, i, inExt, j, len, loader, loaderModule, loaderModules, mapPath, outExt, outPath, path, ref, relativePath, remainingLoaderModules, sourceMap, src, webpackLoaders;
  if (m.init) {
    return init(m.init);
  }
  if (!source) {
    throw new Error("Not initialised");
  }
  path = m.path, (ref = m.rule, inExt = ref.inExt, loaders = ref.loaders, outExt = ref.outExt);
  relativePath = path.substr(source.length);
  outPath = output + "/" + (swapExtension(relativePath, inExt, outExt));
  mapPath = output + "/" + (swapExtension(relativePath, inExt, ".map"));
  loaderModules = [];
  webpackLoaders = [];
  for (j = 0, len = loaders.length; j < len; j++) {
    loader = loaders[j];
    try {
      loaderModule = require(loader);
      loaderModules.push(loaderModule);
      webpackLoaders.push({
        request: "",
        path: path,
        query: "",
        module: loaderModule
      });
    } catch (_error) {
      e = _error;
      return process.send(e);
    }
  }
  src = fs.readFileSync(path, 'utf8');
  sourceMap = null;
  remainingLoaderModules = loaderModules.slice(0);
  i = remainingLoaderModules.length;
  finished = function() {
    mkdirp.sync(Path.dirname(outPath));
    fs.writeFileSync(outPath, src);
    if (sourceMap) {
      fs.writeFileSync(mapPath, sourceMap);
    }
    console.log(path + " -> " + outPath);
    return process.send('complete');
  };
  applyNext = function() {
    var asyncCallback, context, next, out;
    next = remainingLoaderModules.pop();
    i--;
    if (!next) {
      return finished();
    }
    asyncCallback = false;
    context = {
      version: 1,
      request: "",
      query: "",
      sourceMap: sourceMap,
      loaderIndex: i,
      loaders: webpackLoaders,
      async: function() {
        return asyncCallback = true;
      },
      callback: function(err, js, map) {
        asyncCallback = true;
        if (err) {
          process.send(err);
          return;
        }
        src = js;
        sourceMap = map;
        return applyNext();
      }
    };
    out = next.call(context, src);
    if (!asyncCallback) {
      src = out;
      return applyNext();
    }
  };
  return applyNext();
});

//# sourceMappingURL=worker.js.map
